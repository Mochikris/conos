% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/conclass.R
\name{Conos}
\alias{Conos}
\title{Conos R6 class}
\description{
The class encompasses sample collections, providing methods for calculating and visualizing joint graph and communities.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{samples}}{list of samples (Pagoda2 or Seurat objects)}

\item{\code{pairs}}{pairwise alignment results}

\item{\code{graph}}{alignment graph}

\item{\code{clusters}}{list of clustering results named by clustering type}

\item{\code{expression.adj}}{adjusted expression values}

\item{\code{embedding}}{joint embedding}

\item{\code{n.cores}}{number of cores}

\item{\code{misc}}{list with unstractured additional info}

\item{\code{override.conos.plot.theme}}{}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Conos$new()}}
\item \href{#method-addSamples}{\code{Conos$addSamples()}}
\item \href{#method-buildGraph}{\code{Conos$buildGraph()}}
\item \href{#method-getDifferentialGenes}{\code{Conos$getDifferentialGenes()}}
\item \href{#method-findCommunities}{\code{Conos$findCommunities()}}
\item \href{#method-plotPanel}{\code{Conos$plotPanel()}}
\item \href{#method-embedGraph}{\code{Conos$embedGraph()}}
\item \href{#method-plotClusterStability}{\code{Conos$plotClusterStability()}}
\item \href{#method-plotGraph}{\code{Conos$plotGraph()}}
\item \href{#method-correctGenes}{\code{Conos$correctGenes()}}
\item \href{#method-propagateLabels}{\code{Conos$propagateLabels()}}
\item \href{#method-getClusterCountMatrices}{\code{Conos$getClusterCountMatrices()}}
\item \href{#method-getDatasetPerCell}{\code{Conos$getDatasetPerCell()}}
\item \href{#method-getJointCountMatrix}{\code{Conos$getJointCountMatrix()}}
\item \href{#method-clone}{\code{Conos$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
initialize Conos class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$new(
  x,
  ...,
  n.cores = parallel::detectCores(logical = FALSE),
  verbose = TRUE,
  override.conos.plot.theme = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{a named list of pagoda2 or Seurat objects (one per sample)}

\item{\code{n.cores}}{number of cores (default=parallel::detectCores(logical=FALSE))}

\item{\code{verbose}}{provide verbose output}

\item{\code{override.conos.plot.theme}}{(default=FALSE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a new 'Conos' object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-addSamples"></a>}}
\if{latex}{\out{\hypertarget{method-addSamples}{}}}
\subsection{Method \code{addSamples()}}{
initialize or add a set of samples to the conos panel. Note: this will simply add samples, but will not update graph, clustering, etc.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$addSamples(x, replace = FALSE, verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{a named list of pagoda2 or Seurat objects (one per sample)}

\item{\code{replace}}{whether the existing samples should be purged before adding new ones}

\item{\code{verbose}}{provide verbose output}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
invisible view of the full sample list
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-buildGraph"></a>}}
\if{latex}{\out{\hypertarget{method-buildGraph}{}}}
\subsection{Method \code{buildGraph()}}{
Build the joint graph that encompasses all the samples, establishing weighted inter-sample cell-to-cell links
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$buildGraph(
  k = 15,
  k.self = 10,
  k.self.weight = 0.1,
  alignment.strength = NULL,
  space = "PCA",
  matching.method = "mNN",
  metric = "angular",
  k1 = k,
  data.type = "counts",
  l2.sigma = 1e+05,
  var.scale = TRUE,
  ncomps = 40,
  n.odgenes = 2000,
  matching.mask = NULL,
  exclude.samples = NULL,
  common.centering = TRUE,
  verbose = TRUE,
  base.groups = NULL,
  append.global.axes = TRUE,
  append.decoys = TRUE,
  decoy.threshold = 1,
  n.decoys = k * 2,
  score.component.variance = FALSE,
  snn = FALSE,
  snn.quantile = 0.9,
  min.snn.jaccard = 0,
  min.snn.weight = 0,
  snn.k = k.self,
  balance.edge.weights = FALSE,
  balancing.factor.per.cell = NULL,
  same.factor.downweight = 1,
  k.same.factor = k,
  balancing.factor.per.sample = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{k}}{(default=15)}

\item{\code{k}}{k.self (default=10)}

\item{\code{k}}{k.self.weight (default=0.1)}

\item{\code{k}}{alignment.strength (default=NULL)}

\item{\code{k}}{space (default='PCA')}

\item{\code{k}}{matching.method (default=='mNN')}

\item{\code{k}}{metric (default='angular')}

\item{\code{k}}{k1 (default=k)}

\item{\code{k}}{data.type (default='counts')}

\item{\code{k}}{l2.sigma (default=1e5)}

\item{\code{k}}{var.scale (default=TRUE)}

\item{\code{k}}{ncomps (default=40)}

\item{\code{k}}{n.odgenes (default=2000)}

\item{\code{k}}{neighborhood.average (default=FALSE)}

\item{\code{k}}{neighborhood.average.k (default=10)}

\item{\code{k}}{matching.mask (default=NULL)}

\item{\code{k}}{exclude.samples (default=NULL)}

\item{\code{k}}{common.centering (default=TRUE)}

\item{\code{k}}{base.groups (default=NULL)}

\item{\code{k}}{append.global.axes (default=TRUE)}

\item{\code{k}}{append.decoys (default=TRUE)}

\item{\code{k}}{decoy.threshold (default=1)}

\item{\code{k}}{n.decoys (default=k*2)}

\item{\code{k}}{score.component.variance (default=FALSE)}

\item{\code{k}}{balance.edge.weights (default=FALSE)}

\item{\code{k}}{balancing.factor.per.cell (default=NULL)}

\item{\code{k}}{same.factor.downweight (default=1.0)}

\item{\code{k}}{k.same.factor (default=k)}

\item{\code{k}}{balancing.factor.per.sample (default=NULL)}

\item{\code{verbose}}{provide verbose output}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
joint graph to be used for downstream analysis
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getDifferentialGenes"></a>}}
\if{latex}{\out{\hypertarget{method-getDifferentialGenes}{}}}
\subsection{Method \code{getDifferentialGenes()}}{
Calculates differential genes. Estimates base mean, z-score, p-values, specificity, precision, expressionFraction, AUC (if append.auc=TRUE)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$getDifferentialGenes(
  clustering = NULL,
  groups = NULL,
  z.threshold = 3,
  upregulated.only = FALSE,
  verbose = TRUE,
  plot = FALSE,
  n.genes.to.show = 10,
  inner.clustering = FALSE,
  append.specificity.metrics = TRUE,
  append.auc = TRUE,
  n.cores = self$n.cores
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{clustering}}{name of the clustering to use}

\item{\code{groups}}{a factor on cells to use for coloring.}

\item{\code{z.threshold}}{(default=3.0)}

\item{\code{upregulated.only}}{(default=FALSE)}

\item{\code{verbose}}{provide verbose output}

\item{\code{n.genes.to.show}}{(default=10)}

\item{\code{inner.clustering}}{(default=FALSE)}

\item{\code{append.specificity.metrics}}{(default=TRUE)}

\item{\code{append.auc}}{(default=FALSE)}

\item{\code{n.cores}}{number of cores (default=parallel::detectCores(logical=FALSE))}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list of DE results
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-findCommunities"></a>}}
\if{latex}{\out{\hypertarget{method-findCommunities}{}}}
\subsection{Method \code{findCommunities()}}{
find joint communities
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$findCommunities(
  method = leiden.community,
  min.group.size = 0,
  name = NULL,
  test.stability = FALSE,
  stability.subsampling.fraction = 0.95,
  stability.subsamples = 100,
  verbose = TRUE,
  cls = NULL,
  sr = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method}}{community detection method (igraph syntax)}

\item{\code{min.group.size}}{minimal allowed community size}

\item{\code{name}}{optional name of the clustering result (will default to the algorithm name)}

\item{\code{verbose}}{provide verbose output}

\item{\code{...}}{extra parameters are passed to the specified community detection method}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
invisible list containing identified communities (groups) and the full community detection result (result)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plotPanel"></a>}}
\if{latex}{\out{\hypertarget{method-plotPanel}{}}}
\subsection{Method \code{plotPanel()}}{
plot panel of individual embeddings per sample with joint coloring
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$plotPanel(
  clustering = NULL,
  groups = NULL,
  colors = NULL,
  gene = NULL,
  use.local.clusters = FALSE,
  plot.theme = NULL,
  use.common.embedding = FALSE,
  embedding.type = NULL,
  adj.list = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{clustering}}{name of the clustering to use}

\item{\code{groups}}{a factor on cells to use for coloring.}

\item{\code{colors}}{a color factor (named with cell names) use for cell coloring.}

\item{\code{gene}}{show expression of a gene.}

\item{\code{use.common.embedding}}{(default=FALSE)}

\item{\code{embedding.type}}{(default=NULL)}

\item{\code{adj.list}}{(default=NULL)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 object with the panel of plots
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-embedGraph"></a>}}
\if{latex}{\out{\hypertarget{method-embedGraph}{}}}
\subsection{Method \code{embedGraph()}}{
Generate an embedding of a joint graph.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$embedGraph(
  method = "largeVis",
  M = 1,
  gamma = 1,
  alpha = 0.1,
  perplexity = NA,
  sgd_batches = 1e+08,
  seed = 1,
  verbose = TRUE,
  target.dims = 2,
  n.cores = self$n.cores,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method}}{embedding method. Currently 'largeVis' and 'UMAP' are supported}

\item{\code{M, }}{gamma, alpha, sgd__batched - largeVis parameters (defaults are 1, 1, 0.01, 1e8 respectively).}

\item{\code{perplexity}}{perplexity passed to largeVis (defaults to NA).}

\item{\code{seed}}{random seed for the largeVis algorithm. Default: 1.}

\item{\code{verbose}}{provide verbose output}

\item{\code{target.dims}}{number of dimensions for the reduction. Default: 2. Higher dimensions can be used to generate embeddings for subsequent reductions by other methods, such as tSNE}

\item{\code{n.cores}}{number of cores (default=parallel::detectCores(logical=FALSE))}

\item{\code{...}}{additional arguments, passed to UMAP embedding (run ?conos:::embedGraphUmap for more info)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
joint graph embedding
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plotClusterStability"></a>}}
\if{latex}{\out{\hypertarget{method-plotClusterStability}{}}}
\subsection{Method \code{plotClusterStability()}}{
Plot cluster stability statistics.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$plotClusterStability(clustering = NULL, what = "all")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{clustering}}{name of the clustering result to show}

\item{\code{what}}{Show a specific plot (ari - adjusted rand index, fjc - flat Jaccard, hjc - hierarchical Jaccard, dend - cluster dendrogram) (default='all')}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plotGraph"></a>}}
\if{latex}{\out{\hypertarget{method-plotGraph}{}}}
\subsection{Method \code{plotGraph()}}{
Plot joint graph.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$plotGraph(
  color.by = "cluster",
  clustering = NULL,
  groups = NULL,
  colors = NULL,
  gene = NULL,
  plot.theme = NULL,
  subset = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{color.by}}{(default='cluster')}

\item{\code{clustering}}{name of the clustering to use}

\item{\code{groups}}{a factor on cells to use for coloring.}

\item{\code{colors}}{a color factor (named with cell names) use for cell coloring.}

\item{\code{gene}}{show expression of a gene.}

\item{\code{subset}}{a subset of cells to show.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
ggplot2 plot of joint graph
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-correctGenes"></a>}}
\if{latex}{\out{\hypertarget{method-correctGenes}{}}}
\subsection{Method \code{correctGenes()}}{
Smooth expression of genes, so they better represent structure of the graph.
  Use diffusion of expression on graph with the equation dv = exp(-a * (v + b))
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$correctGenes(
  genes = NULL,
  n.od.genes = 500,
  fading = 10,
  fading.const = 0.5,
  max.iters = 15,
  tol = 0.005,
  name = "diffusion",
  verbose = TRUE,
  count.matrix = NULL,
  normalize = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{genes}}{list of genes for smoothing}

\item{\code{n.od.genes}}{if 'genes' is NULL, top n.od.genes of overdispersed genes are taken across all samples. Default: 500.}

\item{\code{fading}}{level of fading of expression change from distance on the graph (parameter 'a' of the equation). Default: 10.}

\item{\code{fading.const}}{minimal penalty for each new edge during diffusion (parameter 'b' of the equation). Default: 0.5.}

\item{\code{max.iters}}{maximal number of diffusion iterations. Default: 15.}

\item{\code{tol}}{tolerance after which the diffusion stops. Default: 5e-3.}

\item{\code{name}}{name to save the correction. Default: diffusion.}

\item{\code{verbose}}{provide verbose output}

\item{\code{count.matrix}}{alternative gene count matrix to correct (rows: genes, columns: cells; has to be dense matrix). Default: joint count matrix for all datasets.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-propagateLabels"></a>}}
\if{latex}{\out{\hypertarget{method-propagateLabels}{}}}
\subsection{Method \code{propagateLabels()}}{
Estimate labeling distribution for each vertex, based on provided labels.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$propagateLabels(labels, method = "diffusion", ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{method}}{type of propagation. Either 'diffusion' or 'solver'. 'solver' gives better result
but has bad asymptotics, so is inappropriate for datasets > 20k cells. (default='diffusion')}

\item{\code{...}}{additional arguments for conos:::propagateLabels* functions}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
matrix with distribution of label probabilities for each vertex by rows.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getClusterCountMatrices"></a>}}
\if{latex}{\out{\hypertarget{method-getClusterCountMatrices}{}}}
\subsection{Method \code{getClusterCountMatrices()}}{
Estimate per-cluster molecule count matrix by summing up the molecules of each gene for all of the cells in each cluster.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$getClusterCountMatrices(
  clustering = NULL,
  groups = NULL,
  common.genes = TRUE,
  omit.na.cells = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{clustering}}{name of the clustering to use}

\item{\code{groups}}{a factor on cells to use for coloring.}

\item{\code{common.genes}}{bring individual sample matrices to a common gene list}

\item{\code{omit.na.cells}}{if set to FALSE, the resulting matrices will include a first column named 'NA' that will report total molecule counts for all of the cells that were not covered by the provided factor.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a list of per-sample uniform dense matrices with rows being genes, and columns being clusters
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getDatasetPerCell"></a>}}
\if{latex}{\out{\hypertarget{method-getDatasetPerCell}{}}}
\subsection{Method \code{getDatasetPerCell()}}{
applies 'getCellNames()' on all samples
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$getDatasetPerCell()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
list of cellnames for all samples
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getJointCountMatrix"></a>}}
\if{latex}{\out{\hypertarget{method-getJointCountMatrix}{}}}
\subsection{Method \code{getJointCountMatrix()}}{
something
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$getJointCountMatrix(raw = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{raw}}{If TRUE, return merged "raw" count matrices. Otherwise, return the merged count matrices.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list of merged count matrices
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Conos$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
